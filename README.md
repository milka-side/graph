# Комʼютерний проєкт
# Тема: Порівняльний аналіз алгоритмів пошуку найкоротшого шляху
## 1. Постановка задачі

Метою даної роботи є дослідження ефективності алгоритмів пошуку найкоротшого шляху в орієнтованих графах. Основний фокус зосереджено на роботі з розрідженими графами.

**Основні вимоги:**
1.  Імплементація класичного алгоритму **Дейкстри**.
2.  Імплементація алгоритму **Беллмана-Форда** (для обробки графів з від'ємними вагами).
3.  Імплементація нового алгоритму **Duan et al. (2025)** .
4.  Проведення порівняльного аналізу продуктивності залежності часу виконання від коефіцієнта розрідженості графа та кількості вершин.
---
## 2. Опис реалізованих алгоритмів

### 2.1 Алгоритм Беллмана-Форда (`bellman_ford_algorithm`)
Класичний алгоритм, що дозволяє знаходити найкоротші шляхи у графі, який може містити ребра з від'ємною вагою.

* **Принцип роботи:** Алгоритм ітеративно ( $N-1$ разів) релаксує всі ребра графа. На $N$-й ітерації перевіряється наявність циклів з від'ємною сумарною вагою.
* **Складність:** $O(V \cdot E)$.
* **Особливості реалізації:**
    * Використовує матрицю суміжності.
    * Повертає виключення `ValueError`, якщо знайдено негативний цикл.
    * Відновлює шлях через масив батьківських вершин (`parents`).

### 2.2 Алгоритм Дейкстри (`dijksta_algorithm`)
Алгоритм для знаходження найкоротших шляхів у графах без ребер з від'ємною вагою.

* **Принцип роботи:** Жадібний алгоритм. На кожному кроці обирається невідвідана вершина з найменшою поточною відстанню, після чого відбувається релаксація її сусідів.
* **Особливості реалізації:**
    * Працює на матриці суміжності.
    * Повертає кортеж `(distance, path)`.

### 2.3 Алгоритм Duan et al. (2025)
*Статус: В процесі розробки / Інтеграції.*
Новітній алгоритм, описаний у роботі "Breaking the Sorting Barrier...", який пропонує швидший підхід для зважених орієнтованих графів, теоретично наближаючись до лінійного часу $O(E + V)$ або $O(E + V \log \log V)$ за певних умов, уникаючи повного сортування, притаманного класичним підходам.

---

## 3. Технічна документація

У цьому розділі наведено детальний опис функціоналу, реалізованого в рамках проекту. Опис включає призначення функцій, вхідні параметри, вихідні дані та обробку виключних ситуацій.
### 3.1. Алгоритми пошуку шляху
#### Функція: bellman_ford_algorithm
Реалізує алгоритм Беллмана-Форда для пошуку найкоротшого шляху у зваженому графі. Ключовою особливістю є здатність працювати з графами, що містять ребра з від'ємною вагою.

* **Вхідні параметри:**
    * `graph`: Квадратна матриця суміжності (список списків), де значення відображають вагу ребра між вершинами. Відсутність ребра позначається як нескінченність, а діагональні елементи дорівнюють нулю.
    * `start_vertex`: Цілочисельний індекс початкової вершини.
    * `end_vertex`: Цілочисельний індекс кінцевої вершини.
* **Результат:**
    * Повертає кортеж, що складається з двох елементів: найкоротшої відстані та списку індексів вершин, які формують шлях від старту до фінішу. Якщо шлях відсутній, повертається нескінченність та порожній список.

#### Функція: dijksta_algorithm
Реалізує класичний алгоритм Дейкстри для пошуку найкоротшого шляху. Алгоритм оптимізовано для графів з невід'ємними вагами.

* **Вхідні параметри:**
    * `graph`: Матриця суміжності графа.
    * `start_vertex`: Індекс стартової вершини.
    * `end_vertex`: Індекс цільової вершини.
* **Результат:**
    * Повертає кортеж із двох елементів: мінімальної відстані та відновленого шляху у вигляді списку вершин.
* **Допоміжна логіка (min_index):**
    * Для вибору наступної вершини використовується допоміжна функція, яка шукає невідвідану вершину з мінімальною поточною відстанню шляхом лінійного проходу по списку відстаней.

### 3.2. Робота з даними та файлова система

#### Функція: load_csv_to_matrix
Відповідає за зчитування графа із зовнішнього файлу формату CSV та його конвертацію у внутрішнє представлення (матрицю суміжності).

* **Формат вхідного файлу:**
    * Очікується файл, де кожен рядок описує одне ребро у форматі: *Джерело, Призначення, Вага*.
* **Логіка роботи:**
    1.  Здійснюється парсинг файлу та формування множини унікальних вершин.
    2.  Вершини сортуються для створення стабільного мапінгу між назвою вузла та його числовим індексом.
    3.  Створюється матриця розміром N x N, ініціалізована значеннями нескінченності.
    4.  Комірки матриці заповнюються вагами ребер згідно з вхідними даними.
* **Результат:**
    * Повертає повністю сформовану матрицю суміжності.

### 3.3. Бенчмаркінг та візуалізація

#### Функція: run_benchmark_with_bellman
Основна функція для проведення порівняльного аналізу ефективності алгоритмів. Вона автоматизує процес тестування, збору метрик та візуалізації результатів.

* **Вхідні параметри:**
    * Функції реалізації алгоритмів (генератор графів, Дейкстра, новий алгоритм Duan et al., опціонально Беллман-Форд).
    * `n_nodes`: Фіксована кількість вершин для серії експериментів.
    * `output_file`: Шлях до файлу, куди буде збережено результуючий графік.
* **Функціонал:**
    * Проводить ітерації по заданому списку коефіцієнтів розрідженості (sparsity) від 0.05 до 0.7.
    * Для кожного коефіцієнта генерує випадковий граф та заміряє час виконання кожного алгоритму.
    * Будує графік залежності часу виконання від щільності графа, використовуючи логарифмічну шкалу для осі часу.
    * Зберігає отриманий графік у файл зображення (PNG).
      
 #### Функція: generate_sparse_directed_graph
 Відповідає за генерацію випадкових орієнтованих зважених графів з заданими параметрами. Графи формуються як матриця суміжності, що дозволяє ефективно реалізувати алгоритми пошуку.
 * **Вхідні параметри:**
    * `n`: Ціле число - кількість вершин у графі. Визначає розмірність матриці суміжності.
    * `density`: Число з плаваючою точкою в діапазоні [0.0, 1.0] - коефіцієнт розрідженості/щільності графа. Визначає ймовірність існування ребра між будь-якими двома різними вершинами. Значення 0.0 відповідає порожньому графу (лише діагональні елементи), 1.0 - повному графу.
    * `max_w`: Ціле число - максимальна вага ребра. Ваги генеруються випадковим чином в діапазоні від 1 до max_w.
* **Логіка роботи:**
    1.  Ініціалізується квадратна матриця розміром n × n зі значеннями math.inf, що позначає відсутність ребра.
    2.  Діагональні елементи встановлюються в 0 (відстань від вершини до самої себе).
    3.  Для кожної пари різних вершин (i, j) генерується випадкове число в діапазоні [0, 1). Якщо це число менше за density, то створюється ребро з випадковою вагою від 1 до max_w.
    4.  Результуюча матриця повертається як об'єкт типу Graph
* **Результат:**
    * Повертає матрицю суміжності графа типу Graph, де кожен елемент graph[i][j] представляє вагу ребра від вершини i до вершини j.
 
#### Функція: bmssp_path
 Реалізує новий алгоритм пошуку найкоротшого шляху, описаний у роботі Duan et al. (2025). Алгоритм використовує багатокрокове рекурсивне дослідження графа для прискорення пошуку на великих розріджених графах.
 * **Вхідні параметри:**
    * `graph`: Матриця суміжності графа.
    * `source`: Ціле число - індекс початкової вершини.
    * `target`: Ціле число - індекс цільової вершини.
    * `l`: Ціле число (необов'язковий, за замовчуванням 2) - глибина рекурсії. Визначає кількість рівнів рекурсивного дослідження.
    * `k_param`: Ціле число (необов'язковий, за замовчуванням 50) - максимальна кількість вершин для обробки на кожному рівні.
* **Логіка роботи:**
    1.  Ініціалізується масив відстаней dist з нескінченностями та масив батьківських вершин parent.
    2.  Відстань до початкової вершини встановлюється в 0.
    3.  Викликається рекурсивна функція bmssp_recur з початково
    4.  На кожному рівні рекурсії:
    4.1. Якщо l ≤ 0, виконується обмежений пошук за алгоритмом Дейкстри серед k_param + 1 найближчих вершин.
    4.2 Інакше: вибираються опорні вершини (pivots) з множини S, виконується рекурсивний виклик для кожної опорної вершини, після чого оновлюються відстані до сусідів.Результуюча матриця повертається як об'єкт типу Graph
    5. Після завершення рекурсії відновлюється шлях від цільової вершини до початкової через масив parent.
 
### Допоміжна функція: find_pivots
Призначена для вибору опорних вершин та обчислення досяжних вершин у межах k_steps кроків.
 * **Вхідні параметри:**
    * `graph`: Матриця суміжності графа.
    * `dist`: Масив поточних відстаней до вершин.
    * `S`: ЦМножина вершин-кандидатів.
    * `k_steps`: Максимальна кількість кроків для обчислення досяжності.
    * `p_limit`: Максимальна кількість опорних вершин.
* **Логіка роботи:**
    1.  Сортує множину S за зростанням відстані.
    2.  Вибирає перші p_limit вершин як опорні (P).
    3.  Шляхом BFS обмеженої глибини (k_steps) обчислює множину вершин (W), досяжних з опорних.
    4.  Повертає кортеж (P, W).
 
* **Результат:**
    * path_edges: Список кортежів виду (u, v), де кожен кортеж представляє ребро у знайденому шляху. Список містить ребра у порядку від початкової до кінцевої вершини.
    * total_distance: Число з плаваючою точкою - загальна довжина знайденого найкоротшого шляху.

### Функція: main

Головна функція програми, яка координує всі компоненти системи. Відповідає за парсинг аргументів командного рядка, ініціалізацію графа, виконання алгоритмів та управління потоком виконання.

* **Структура аргументів командного рядка:**

* **Аргументи конфігурації графа**

-n, --nodes (ціле число, за замовчуванням: 500)

*Призначення:* Визначає кількість вершин у згенерованому випадковому графі.
*Діапазон:* Має бути додатним цілим числом.

-d, --density (число з плаваючою точкою, за замовчуванням: 0.3)

*Призначення:* Задає ймовірність існування ребра між будь-якими двома різними вершинами.
*Діапазон:* Теоретично [0.0, 1.0], практично рекомендовано 0.05-0.7.

-w, --max-weight (ціле число, за замовчуванням: 10)

*Призначення:* Максимальна вага випадкового ребра.
*Обмеження:* Має бути додатним числом.

* **Аргументи визначення маршруту** **
   
  --start (ціле число, за замовчуванням: 0)
  
*Призначення:* Індекс початкової вершини шляху.
*Перевірка:* Програма перевіряє, чи знаходиться значення в межах [0, n-1].
*Поведінка при помилці:* Виводиться попередження та використовується значення 0.

--target (ціле число, необов'язковий)

*Призначення:* Індекс цільової вершини шляху.
*Спеціальне значення:* Якщо не вказано, використовується остання вершина (n-1).

* **Аргументи налаштування алгоритму BMSSP**
  
  -l, --recursion-depth (ціле число, за замовчуванням: 2)

*Призначення:* Глибина рекурсії для алгоритму BMSSP.
*Вплив на продуктивність:*
* Малі значення (1-2): краще для малих графів
* Великі значення (3-4): можуть покращити швидкодію на великих графах
*Обмеження:* Має бути невід'ємним числом.

* **Аргументи роботи з файлами**
  
  --source (рядок, необов'язковий)
  
*Призначення:* Шлях до CSV-файлу для завантаження графа.
*Формат файлу:* Три колонки без заголовка: source, target, weight
*Поведінка:*
* Якщо вказано, генерування випадкового графа пропускається
* Кількість вершин визначається автоматично
* Імена вершин конвертуються в індекси
*Обробка помилок:* При відсутності файлу виводиться повідомлення та програма завершується.

* **Аргументи бенчмаркінгу**
  
  --force-benchmark (прапорець)
  
*Призначення:* Примусовий запуск бенчмаркінгу навіть при роботі з CSV-файлом.
*За замовчуванням:* Виключено (бенчмарк не виконується при використанні --source)
*Використання:* Корисно для тестування алгоритмів на реальних даних.

--benchmark-output (рядок, за замовчуванням: "benchmark.png")

*Призначення:* Ім'я файлу для збереження графіка результатів бенчмарку.
*Формат:* Підтримуються формати PNG, JPG, PDF, SVG.

* **Діагностичні аргументи**
  
  --print-matrix (прапорець)

*Призначення:* Виведення матриці суміжності графа в консоль.
*Рекомендації:* Використовувати лише для малих графів (n ≤ 20).

* **Обробка конфліктуючих аргументів**
  --source vs -n/-d/-w: При наявності --source аргументи конфігурації графа ігноруються.
*Валідація індексів:* Автоматична корекція некоректних значень --start та --target.
*Умовний бенчмарк:* Бенчмарк запускається тільки для згенерованих графів, якщо не вказано --force-benchmark.


## 4. Висновок

Проєкт реалізує комплексну систему для порівняльного аналізу алгоритмів пошуку найкоротшого шляху. Гнучка система аргументів командного рядка дозволяє:

1. Генерувати графи з різними параметрами розміру та щільності
2. Завантажувати реальні дані з CSV-файлів
3. Налаштовувати параметри алгоритмів, особливо нового алгоритму BMSSP
4. Контролювати діагностичний вивід для налагодження
5. Проводити автоматизований бенчмаркінг з візуалізацією результатів  







## 5. Розподіл обов'язків

Робота над проектом була розподілена між членами команди наступним чином:

| Виконавець | Зона відповідальності | Деталі завдання |
| :--- | :--- | :--- |
| **Дмитрій** | Класичні алгоритми | Реалізація алгоритму Дейкстри та алгоритму Беллмана-Форда. Написання базової логіки пошуку шляху. |
| **Мілана та Олена** | Новий алгоритм | Дослідження та імплементація алгоритму Duan et al. (2025). Оптимізація структур даних, налагодження та інтеграція з загальним інтерфейсом.|
| **Юлія** | Генерація даних | Написання генератора випадкових розріджених графів для тестування (функція `generator_func`). |
| **Андрій** | Аналітика | Реалізація зчитування графів з файлів (`.csv`), написання модуля бенчмаркінгу та побудова графіків за допомогою `matplotlib`. |
